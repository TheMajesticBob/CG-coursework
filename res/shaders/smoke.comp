#version 440 core

// Process particles in blocks of 128
layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;
// SSBO binding
layout(std430, binding = 0) buffer PositionBuffer { vec4 positions[]; };
layout(std430, binding = 1) buffer VelocityBuffer { vec4 velocities[]; };

uniform bool isEmitting;

// Particle vars
uniform vec2 initialLifetime;
uniform vec2 initialSize;
uniform vec2 initialSpeed;
uniform vec3 initialDirection;

// Time variables for calculations
uniform float delta_time;
uniform float time;

// Box dimentions
uniform vec3 max_dims;

uniform vec4 windDirection;


// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand(vec2 co)
{
    highp float a = 12.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}

float hash( float n )
{
	return rand(vec2(n, sin(n)));
    //return fract(sin(n)*43758.5453);
}

void SpawnNewParticle(in uint index, out vec3 newPos, out vec3 newVel, out float newSize, out float lifetime)
{
	float noise;
	// Calculate random 0, 1 float for particle size
	noise = ( hash( time * 498426.123 ) + 1.0 ) / 2.0;
	newSize = noise * ( initialSize.y - initialSize.x ) + initialSize.x;

	// Calculate random -1, 1 float for X position
	noise = hash( newSize * time * 9745123.11 ) - 0.5;
	float noiseX = noise * max_dims.x;
	noiseX -= sign(noiseX) * newSize;

	// Calculate random -1, 1 float for Z position
	noise = hash( noiseX * delta_time * 9856423.7 ) - 0.5; 
	float noiseZ = noise * max_dims.z;
	noiseZ -= sign(noiseZ) * newSize;

	// Calculate 0, 1 float for particle speed
	noise = ( hash( noiseZ * time * 198523.4 ) + 1.0 ) / 2.0;
	float speed = noise * ( initialSpeed.y - initialSpeed.x ) + initialSpeed.x;

	// Calculate 0, 1 float for particle lifetime
	noise = ( hash( speed * time * 417588.1 ) + 1.0 ) / 2.0;
	lifetime = noise * ( initialLifetime.y - initialLifetime.x ) + initialLifetime.x;

	newPos = vec3( noiseX, -(max_dims.y / 2.0 + newSize * 2.0), noiseZ ); 
	newVel = vec3( initialDirection * speed );
}

void main() 
{
	uint index = gl_GlobalInvocationID.x;

	// Read the current position and velocity from the buffers
	vec4 vel = velocities[index];
	vec4 pos = positions[index];

	// Read the real values
	vec3 realVelocity = vel.xyz;
	vec3 realPosition = pos.xyz;
	float remainingLifetime = vel.w;
	float metaballSize = pos.w;
	
	// Particle dying
	remainingLifetime -= delta_time;

	if( remainingLifetime < 0 )
	{
		if( isEmitting )
		{
			SpawnNewParticle(index, realPosition, realVelocity, metaballSize, remainingLifetime);
		} else {
			metaballSize = 0.0;
		}
	} else {
		// Update particle variables
		realPosition = vec3( realPosition + realVelocity * delta_time );
		realVelocity = realVelocity;
		metaballSize = mix( metaballSize, 1.0, 1 - ( remainingLifetime / initialLifetime.y ) * 0.0001 );
	}

	// Store the new position and velocity back into the buffers
	// velocities[index] = vec4( realVelocity, remainingLifetime ); //

	vec3 windDir = windDirection.xyz;
	float windStrength = windDirection.w;

	velocities[index] = vec4( mix( realVelocity, realVelocity + windDir * windStrength, delta_time ), remainingLifetime);
	positions[index] = vec4( realPosition, metaballSize );
}